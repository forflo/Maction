#include <stdbool.h>
#include <pthread.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <alsa/asoundlib.h>

#include "midi_action_lib.h"
#include "slist.h"

/* Registers a note - callback combination. If you need the library
 	to call a function f if the key with note id 40 is pressed. You
 	would call mac_reg_on_note like this:
 	mac_reg_on_note(40, -1, e, callback_vector, param_vector);
 	Param: note = The note id for a specific key on the keyboard
		octave = Currently not used. Every value possible
		env = An initialized environment
		callback = The initialized callback vector containing two
			function pointer
		params = The initialized parameter vector containing two
			void pointer
	Return: 0 if the execution was successful, -1 if it wasn't. */
int mac_reg_on_note(int note, int octave, struct mac_action_env *env, 
                    void *(*callback[2])(void *aram), void *params[2]){
    if(note < 0 || env == NULL || callback == NULL || params == NULL)
        return -1;

    if(callback[0] == NULL || callback[1] == NULL)
        return -1;

    if(params[0] == NULL || params [1] == NULL)
        return -1;

	struct mac_func_note_mapping *map = (struct mac_func_note_mapping*) 
		malloc(sizeof(struct mac_func_note_mapping));
	if(map == NULL)
		return -1;
	map->note = note;
	map->callback = callback;
	map->params = params;

	pthread_mutex_lock(env->mutex);
	if(slist_add(env->actions, (void*) map)){
		free(map);
		return -1;
	}
	pthread_mutex_unlock(env->mutex);

    return 0;
}

/* convenience wrapper for mac_rec_on_note */
int mac_reg_on_note_c(char *note, int octave, struct mac_action_env *env, 
                        void *(*callback[2])(void *aram), void *params[2]){
    int i;

    if(note == NULL || env == NULL || callback == NULL || params == NULL)
        return -1;

	/* TODO: Impl*/

    return 0;
}

/* Creates a new mac_action_env object which represents
 	the combination of a mac_midi_device object, a
 	key (note id) - callback function mapping and an
 	main event loop with pthread control structures
 	included
 	Param: mdev = An initialized mac_midi_device object
 	Return: NULL on failure, an initialized Pointer != NULL
 		if the function executed successfully */
struct mac_action_env *mac_init_env(struct mac_midi_device *mdev){
	if(mdev == NULL)
		return NULL;
	if(mdev->sequencer == NULL)
		return NULL;

	struct mac_action_env *temp = (struct mac_action_env *)
			malloc(sizeof(struct mac_action_env));
	if(temp == NULL)
		return NULL;

	temp->mdev = mdev;
	temp->event_loop = NULL;
	temp->mutex = (pthread_mutex_t *) malloc(sizeof(pthread_mutex_t));
	if(temp->mutex == NULL){
		free(temp);
		return NULL;
	}
	if(pthread_mutex_init(temp->mutex, NULL)){
		free(temp->mutex);
		free(temp);
		return NULL;
	}
	temp->actions = slist_init();
	if(temp->actions == NULL){
		free(temp);
		return NULL;
	}

	return temp;
}

/* Creates a new mac_midi_device object. This object is used
	to represent a midi device that generates NOTEON and NOTEOFF
	events inside the asound library. 
	Param: client = The client id of the midi device
		port = The port id of the midi device (midi keyboards usually
			own two ports, one for input and one for the output 
 		name = The name of the device 
 	Return: An initialized ponter to a new mac_midi_device object or
 		NULL if an error occured */
struct mac_midi_device *mac_init_midi_dev(int client, int port, char *name){
	if (client < 0 || port < 0)
		return NULL;

	struct mac_midi_device *temp = (struct mac_midi_device *)
			malloc(sizeof(struct mac_midi_device));
	if(temp == NULL)
		return NULL;

	temp->port = port;
	temp->client = client;
	temp->connected = false;
	temp->sequencer = new_seq(name);
	if(temp->sequencer == NULL){
		free(temp);
		return NULL;
	}

	return temp;
}

/* Starts the event_loop in a new thread. The thread structure
 	will then be stored inside an mac_action_env object.
	Param: env = The mac_action_env object representing one of many
		possible environments 
	Return: -1 on failure, 0 on success */
int mac_start_event_loop(struct mac_action_env *env){
	if(env == NULL)
		return -1;
	pthread_t *thread = (pthread_t *) malloc(sizeof(pthread_t));
	if(pthread_create(thread, NULL, (void *(*)(void*)) mac_event_loop, (void *) env)){
		free(thread);
		return -1;
	}
	env->event_loop = thread;
	return 0;
}

/* Configures the snd_seq_t (mdev->sequencer) structure in such 
 	a way that it receives the events generated by client with
 	id mdev->client on port mdev->port 
 	Param: mdev = An initialized mac_midi_device structure
 	Return: -1 on error, 0 on success */ 
int mac_connect(struct mac_midi_device *mdev){
	if(mdev == NULL)
		return -1;
	if(snd_seq_connect_from(mdev->sequencer, 0, mdev->client, mdev->port) <0)
		return -1;
	mdev->connected = true;
	return 0;
}

/* Creates a pre configured instance of the asound structure
	snd_seq_t.
	Param: name = The name to use for the sequencer
	Return: An initialized structure pointer or NULL on failure */
static snd_seq_t *new_seq(char *name){
    snd_seq_t *temp;
    int portid;

    if(name == NULL)
        return NULL;

    if(snd_seq_open(&temp, "default", SND_SEQ_OPEN_INPUT, 0) < 0)
        return NULL; 

    snd_seq_set_client_name(temp, name);
    if((portid = snd_seq_create_simple_port(temp, "name",
                    SND_SEQ_PORT_CAP_WRITE | SND_SEQ_PORT_CAP_SUBS_WRITE,
                    SND_SEQ_PORT_TYPE_APPLICATION)) <0)
        return NULL;

    return temp;
}

/* This procedure polls for events generated by the midi-keyboard
	configured in env->mdev. This function is intended to be 
 	executed in the background using pthread functions.
 	Every time a NOTEON or NOTEOFF event is taken from the queue,
 	the list env->actions is traverted to search for the
 	appropriate note - callback mapping. 
 	Param: env = An initialized environment object
 	Return: nothing */
static void mac_event_loop(struct mac_action_env *env){
	int npfd, i, rc;
	struct pollfd *pfd;
	struct mac_func_note_mapping *temp;

	if(env == NULL)
		return;

	npfd = snd_seq_poll_descriptors_count(env->mdev->sequencer, POLLIN);
	pfd = (struct pollfd *) alloca(npfd * sizeof(struct pollfd));
	snd_seq_poll_descriptors(env->mdev->sequencer, pfd, npfd, POLLIN);

	snd_seq_event_t *event;

	while(true){
		if(poll(pfd, npfd, POLL_TIMEOUT) > 0){
			do {
				snd_seq_event_input(env->mdev->sequencer, &event);
				switch(event->type){
					case SND_SEQ_EVENT_NOTEON:
						pthread_mutex_lock(env->mutex);	
						for(i=0; i<env->actions->len; i++){
							temp = slist_get_at(i, env->actions, &rc);
							if(rc == -1 || temp == NULL)
								break;

							if(event->data.note.note == temp->note)
								/* mapping found. Calling function */
								temp->callback[0](temp->params[0]);
						}
						pthread_mutex_unlock(env->mutex);
						break;
					case SND_SEQ_EVENT_NOTEOFF:
						pthread_mutex_lock(env->mutex);	
						for(i=0; i<env->actions->len; i++){
							temp = slist_get_at(i, env->actions, &rc);
							if(rc == -1 || temp == NULL)
							   break;

							if(event->data.note.note == temp->note)
								/* mapping found. Calling function */
								temp->callback[1](temp->params[1]);	
						}
						pthread_mutex_unlock(env->mutex);
						break;
					default:
						/* doing nothing is intended */
						break;
				}

				snd_seq_free_event(event);
			} while(snd_seq_event_input_pending(env->mdev->sequencer, 0) >0);	
		}
	}	
}
